# TERMINOLOGIA

## PE FILES

### INTRODUCCION

PE significa **Portable Executable**, es un formato de archivo para ejecutables utilizados en los sistemas operativos Windows, se basa en el formato [[#COFF - Common Object File Format) de archivo (Common Object File Format).

No solo los archivos `.exe` son archivos PE, las [[#DLL Dynamic Link Library) ( `.dll`), los módulos Kernel ( `.srv`), las aplicaciones del panel de control ( `.cpl`) y muchos otros también son archivos PE.

### ESTRUCTURA

Un archivo PE típico sigue la estructura descrita en la siguiente figura:

![foto](./img/Pasted%20image%2020221005161122.png)

#### DOS HEADER
Cada archivo PE comienza con una estructura de 64 bytes llamada encabezado DOS, es lo que hace que el archivo PE sea un ejecutable de MS-DOS.

Aqui se define los magic number para decir que es un MS-DOS.

no es importante para la funcionalidad de los archivos PE en los sistemas Windows modernos, sin embargo, está ahí por razones de compatibilidad con versiones anteriores.  
Este encabezado hace que el archivo sea un ejecutable de MS-DOS, por lo que cuando se carga en MS-DOS, se ejecuta el código auxiliar de DOS en lugar del programa real.  
Sin este encabezado, si intenta cargar el ejecutable en MS-DOS, no se cargará y solo producirá un error genérico.

**ESTRUCTURA**

```bash
typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
```

Esta estructura es importante para el cargador de PE en MS-DOS; sin embargo, solo unos pocos miembros son importantes para el cargador de PE en sistemas Windows, por lo que no cubriremos todo aquí, solo los miembros importantes de la estructura.

-   **`e_magic`:** Este es el primer miembro de la Cabecera de DOS, es una PALABRA por lo que ocupa 2 bytes, por lo general se le llama número mágico. Tiene un valor fijo de `0x5A4D` o `MZ` en ASCII y sirve como una firma que marca el archivo como ejecutable de MS-DOS.
-   **`e_lfanew`:** Este es el último miembro de la estructura de encabezado de DOS, está ubicado en el desplazamiento `0x3C` en el encabezado de DOS y tiene un desplazamiento al inicio de los encabezados de NT. Este miembro es importante para el cargador de PE en los sistemas Windows porque le dice al cargador dónde buscar el encabezado del archivo

#### DOS STUB

Después del encabezado de DOS viene el resguardo de DOS, que es un pequeño ejecutable compatible con MS-DOS 2.0 que simplemente imprime un mensaje de error que dice "Este programa no se puede ejecutar en modo DOS" cuando el programa se ejecuta en modo DOS.

Sin embargo, el usuario puede cambiar este mensaje durante el tiempo de compilación.

##### RICH HEADER

todavía hay una parte de los datos de los que no hemos hablado que se encuentran entre el DOS stub y el comienzo del NT Header.

Este fragmento de datos se conoce comúnmente como Rich Header, es una estructura no documentada que solo está presente en los ejecutables creados con el conjunto de herramientas de Microsoft Visual Studio.  
Esta estructura contiene algunos metadatos sobre las herramientas utilizadas para compilar el ejecutable, como sus nombres o tipos y sus versiones específicas y números de compilación.

Todos los recursos que he leído sobre los archivos PE no mencionaron esta estructura, sin embargo, cuando busqué sobre el encabezado enriquecido, encontré una cantidad decente de recursos, y eso tiene sentido porque el encabezado enriquecido no es en realidad una parte del archivo PE. estructura de formato y se puede poner a cero por completo sin interferir con la funcionalidad del ejecutable, es algo que Microsoft agrega a cualquier ejecutable creado con su conjunto de herramientas de Visual Studio.

Solo sé sobre Rich Header porque he leído los informes sobre el malware Olympic Destroyer, y para aquellos que no saben qué es Olympic Destroyer, es un malware que fue escrito y utilizado por un grupo de amenazas en un intento de interrumpir los Juegos Olímpicos de Invierno de 2018.  
Esta pieza de malware es conocida por tener muchas banderas falsas que se colocaron intencionalmente para causar confusión y atribución errónea, una de las banderas falsas presentes era un encabezado enriquecido.  
Los autores del malware sobrescribieron el encabezado enriquecido original en el ejecutable del malware con el encabezado enriquecido de otro malware atribuido al grupo de amenazas Lazarus para que pareciera que era Lazarus.  
Puede consultar [el informe de Kaspersky](https://securelist.com/the-devils-in-the-rich-header/84348/) para obtener más información al respecto.

![foto](./img/Pasted%20image%2020221005170656.png)

#### NT HEADERS

La parte de encabezados NT contiene tres partes principales:

-   **Firma PE:** una firma de 4 bytes que identifica el archivo como un archivo PE.
-   **Encabezado de archivo:** un encabezado de archivo estándar `COFF`. Contiene alguna información sobre el archivo PE.
-   **Encabezado Opcional:** El encabezado más importante de los Encabezados NT, su nombre es Encabezado Opcional porque algunos archivos como archivos objeto no lo tienen, sin embargo es requerido para archivos de imagen (archivos como archivos `.exe`). Este encabezado proporciona información importante para el cargador del sistema operativo.

para entender mejor esto primero expliquemos este concepto:

- **Relative Virtual Address (RVA):** es solo un desplazamiento desde donde se cargó la imagen en la memoria (la base de la imagen). Entonces, para traducir un RVA a una dirección virtual absoluta, debe agregar el valor del RVA al valor de la base de imágenes. Los archivos PE dependen en gran medida del uso de RVA, como veremos más adelante.

##### NT HEADER (IMAGE_NT_HEADERS)

son una estructura definida en `winnt.h` como `IMAGE_NT_HEADERS`.

- **winnt.h:** Este módulo de C o C++, define los tipos y constantes de Windows de 32 bits que se definido por NT, pero expuesto a través de la API de Win32.

estructura:

```c++
typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
```

podemos ver que tiene tres miembros:

- Un Signature de tipo `DWORD`
- una estructura llamada `FileHeader` de tipo `IMAGE_FILE_HEADER`
- una estructura llamada `OptionalHeader` de tipo `IMAGE_OPTIONAL_HEADER`

Vale la pena mencionar que esta estructura se define en dos versiones diferentes, una para ejecutables de 32 bits (también denominados ejecutables `PE32`) con nombre `IMAGE_NT_HEADERS`y otra para ejecutables de 64 bits (también denominados ejecutables `PE32+`) con nombre `IMAGE_NT_HEADERS64`.  

La principal diferencia entre las dos versiones es la versión utilizada de la estructura `IMAGE_OPTIONAL_HEADER` que tiene dos versiones, `IMAGE_OPTIONAL_HEADER32` para ejecutables de 32 bits y `IMAGE_OPTIONAL_HEADER64` para ejecutables de 64 bits.

##### SIGNATURE

El primer miembro de la estructura `IMAGE_FILE_HEADER` es la firma PE (Signature), es un `DWORD`lo que significa que ocupa 4 bytes.  Siempre tiene un valor fijo `0x50450000` que se traduce `PE\0\0` en ASCII.

![foto](./img/Pasted%20image%2020221006093144.png)

##### FILE HEADER (IMAGE_FILE_HEADER)

También llamado "The COFF File Header", el File Header es una estructura que contiene información sobre el archivo PE.

Estructura:

```c++
typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
```

Es una estructura simple con 7 miembros:

- **`Machine`:** Este es un número que indica el tipo de máquina (Arquitectura de CPU) a la que se dirige el ejecutable, este campo puede tener muchos valores, pero solo nos interesan dos de ellos:
	- `0x8864` que equivale a `AMD64`
	- `0x14c` que equivale a `i386`. 
	- Para obtener una lista completa de los posibles valores, puede consultar la [documentación oficial de Microsoft](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format) .
- **`NumberOfSections`:** este campo contiene el número de secciones (también conocido como el tamaño de la tabla de secciones).
- **`TimeDateStamp`:** una `unix` marca de tiempo que indica cuándo se creó el archivo.
- **`PointerToSymbolTable` y `NumberOfSymbols`:** estos dos campos mantienen el desplazamiento del archivo a la tabla de símbolos COFF y el número de entradas en esa tabla de símbolos, sin embargo, se establecen en `0` lo que significa que no hay una tabla de símbolos COFF presente, esto se hace porque la información de depuración de COFF está obsoleta.
- **`SizeOfOptionalHeader`:** el tamaño del Optional Header.
- **`Characteristics`:** Una bandera que indica los atributos del archivo, estos atributos pueden ser cosas como que el archivo sea ejecutable, que el archivo sea un archivo de sistema y no un programa de usuario, y muchas otras cosas. Puede encontrar una lista completa de estos indicadores en la [documentación oficial de Microsoft](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format) .

![foto](./img/Pasted%20image%2020221006094107.png)

![foto](./img/Pasted%20image%2020221006094149.png)

##### OPTIONAL HEADER (IMAGE_OPTIONAL_HEADER)

El Optional Header es el encabezado más importante de los NT Headers, el PE loader busca información específica proporcionada por ese encabezado para poder cargar y ejecutar el ejecutable.  

Se llama Optional Header porque algunos tipos de archivos, como los archivos de objetos, no lo tienen; sin embargo, este encabezado es esencial para los archivos de imagen. (Ejecutables, DLL, MSI)

No tiene un tamaño fijo, por eso en el File Header se tiene un campo `SizeOfOptionalHeader`.

Estructura del IMAGE_OPTIONAL_HEADER32

```c++
typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
```

Estructura del IMAGE_OPTIONAL_HEADER64

```c++
typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;
```

Las dos versiones son diferentes en dos aspectos:

-   **El tamaño de la estructura en sí (o el número de miembros definidos dentro de la estructura):** `IMAGE_OPTIONAL_HEADER32` tiene 31 miembros mientras que `IMAGE_OPTIONAL_HEADER64`solo tiene 30 miembros, ese miembro adicional en la versión de 32 bits es un nombre DWORD `BaseOfData` que contiene un RVA del comienzo de los datos sección.
-   **El tipo de datos de algunos de los miembros:** Los siguientes 5 miembros de la estructura de encabezado opcional se definen como `DWORD` en la versión de 32 bits y como `ULONGLONG` en la versión de 64 bits:
    -   **`ImageBase`**
    -   **`SizeOfStackReserve`**
    -   **`SizeOfStackCommit`**
    -   **`SizeOfHeapReserve`**
    -   **`SizeOfHeapCommit`**


**Campos de la estructura**

- **`Magic`:** La documentación de Microsoft describe este campo como un número entero que identifica el estado de la imagen, la documentación menciona tres valores comunes:
    
    -   **`0x10B`:** identifica la imagen como ejecutable `PE32`.
    -   **`0x20B`:** identifica la imagen como ejecutable `PE32+`.
    -   **`0x107`:** Identifica la imagen como una imagen ROM.
    
    El valor de este campo es lo que determina si el ejecutable es de 32 bits o de 64 bits, el valor `IMAGE_FILE_HEADER.Machine`  de Windows PE lo ignora.
    
- **`MajorLinkerVersion` y `MinorLinkerVersion`:** Los números de versión principal y secundaria del enlazador.
    
- **`SizeOfCode`:** este campo contiene el tamaño de la sección `.text` de código, o la suma de todas las secciones de código si hay varias secciones.
    
- **`SizeOfInitializedData`:** este campo contiene el tamaño de la sección `.data` de datos inicializados, o la suma de todas las secciones de datos inicializados si hay varias secciones.
    
- **`SizeOfUninitializedData`:** este campo contiene el tamaño de la sección `.bss` de datos no inicializados, o la suma de todas las secciones de datos no inicializados si hay varias secciones.
    
- **`AddressOfEntryPoint`:** Un RVA del punto de entrada cuando el archivo se carga en la memoria. La documentación establece que para las imágenes del programa esta dirección relativa apunta a la dirección inicial y para los controladores de dispositivos apunta a la función de inicialización. Para las DLL, un punto de entrada es opcional y, en el caso de ausencia de punto de entrada, el campo `AddressOfEntryPoint` se establece en `0`.
    
- **`BaseOfCode`:** un RVA del inicio de la sección de código cuando el archivo se carga en la memoria.
    
- **`BaseOfData`( Solo en IMAGE_OPTIONAL_HEADER32):** un RVA del inicio de la sección de datos cuando el archivo se carga en la memoria.
    
- **`ImageBase`:** este campo contiene la dirección preferida del primer byte de la imagen cuando se carga en la memoria (la dirección base preferida), este valor debe ser un múltiplo de 64K. Debido a protecciones de memoria como ASLR y muchas otras razones, la dirección especificada por este campo casi nunca se usa, en este caso el cargador PE elige un rango de memoria no utilizado para cargar la imagen, después de cargar la imagen en esa dirección, el El cargador entra en un proceso llamado reubicación en el que corrige las direcciones constantes dentro de la imagen para que funcionen con la nueva imagen base. Hay una sección especial que contiene información sobre los lugares que necesitarán reparación si se necesita una reubicación. Esa sección se llama sección de reubicación. ( `.reloc`)
    
- **`SectionAlignment`:** este campo contiene un valor que se usa para la alineación de la sección en la memoria (en bytes), las secciones se alinean en los límites de la memoria que son múltiplos de este valor. La documentación establece que este valor predeterminado es el tamaño de página para la arquitectura y no puede ser inferior al valor de `FileAlignment`.
    
- **`FileAlignment`:** Similar a `SectionAligment`, este campo contiene un valor que se usa para la alineación de datos sin procesar de la sección **en el disco** (en bytes), si el tamaño de los datos reales en una sección es menor que el valor `FileAlignment`, el resto del fragmento se rellena con ceros para mantener los límites de la alineación.
    
- **`MajorOperatingSystemVersion`, `MinorOperatingSystemVersion`, `MajorImageVersion`, `MinorImageVersion`,`MajorSubsystemVersion` y `MinorSubsystemVersion`:** Estos miembros de la estructura especifican el número de versión principal del sistema operativo requerido, el número de versión secundaria del sistema operativo requerido, el número de versión principal de la imagen, el número de versión secundaria de la imagen, el número de versión principal número de versión del subsistema y el número de versión menor del subsistema respectivamente.
    
- **`Win32VersionValue`:** un campo reservado que la documentación dice que debe establecerse en `0`.
    
- **`SizeOfImage:`** El tamaño del archivo de imagen (en bytes), incluidos todos los encabezados. Se redondea a un múltiplo de `SectionAlignment` porque este valor se usa al cargar la imagen en la memoria.
    
- **`SizeOfHeaders`:** el tamaño combinado del resguardo de DOS, el encabezado PE (encabezados NT) y los encabezados de sección redondeados a un múltiplo de `FileAlignment`.
    
- **`CheckSum`:** una suma de comprobación del archivo de imagen, se utiliza para validar la imagen en el momento de la carga.
    
- **`Subsystem`:** este campo especifica el subsistema de Windows (si lo hay) que se requiere para ejecutar la imagen. Puede encontrar una lista completa de los posibles valores de este campo en la [documentación oficial de Microsoft](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format) .
    
- **`DLLCharacteristics`:** este campo define algunas características del archivo de imagen ejecutable, como si es compatible a `NX` y si se puede reubicar en tiempo de ejecución. No tengo idea de por qué se llama `DLLCharacteristics`, existe dentro de los archivos de imagen ejecutables normales y define las características que se pueden aplicar a los archivos ejecutables normales. Puede encontrar una lista completa de los posibles indicadores `DLLCharacteristics`en la [documentación oficial de Microsoft](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format) .
    
- **`SizeOfStackReserve`, `SizeOfStackCommit`, `SizeOfHeapReserve` y `SizeOfHeapCommit`:** estos campos especifican el tamaño de la pila para reservar, el tamaño de la pila para confirmar, el tamaño del espacio de almacenamiento dinámico local para reservar y el tamaño del espacio de almacenamiento dinámico local para confirmar, respectivamente.
    
- **`LoaderFlags`:** un campo reservado que la documentación dice que debe establecerse en `0`.
    
- **`NumberOfRvaAndSizes` :** Tamaño de la matriz`DataDirectory`.
    
- **`DataDirectory`:** Una matriz de estructuras`IMAGE_DATA_DIRECTORY`.  Podemos leer mas aqui [[#DATA DIRECTORY)

![foto](./img/Pasted%20image%2020221006162639.png)

##### DATA DIRECTORY

El último miembro de la `IMAGE_OPTIONAL_HEADER`estructura era una matriz de `IMAGE_DATA_DIRECTORY`estructuras definidas de la siguiente manera:

```c++
IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
```

#### SECTION TABLE

es una matriz de encabezados de sección de imagen, hay un encabezado de sección para cada sección en el archivo PE.  
Cada encabezado contiene información sobre la sección a la que se refiere.

#### SECTION HEADER

Después del Optional Header y antes de las secciones, vienen los encabezados de sección. Estos encabezados contienen información sobre las secciones del archivo PE.

Estructura:

```c++
typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
```

- **`Name`:** Primer campo del encabezado de la sección, una matriz de bytes del tamaño `IMAGE_SIZEOF_SHORT_NAME` que contiene el nombre de la sección. `IMAGE_SIZEOF_SHORT_NAME` tiene el valor de `8` significar que el nombre de una sección no puede tener más de 8 caracteres. Para nombres más largos, la documentación oficial menciona una solución completando este campo con un desplazamiento en la tabla de cadenas; sin embargo, las imágenes ejecutables no usan una tabla de cadenas, por lo que esta limitación de 8 caracteres se aplica a las imágenes ejecutables.
- **`PhysicalAddress`o `VirtualSize`:** define varios nombres para la misma cosa, este campo contiene el tamaño total de la sección cuando se carga en la memoria.
- **`VirtualAddress`:** La documentación establece que para las imágenes ejecutables, este campo contiene la dirección del primer byte de la sección en relación con la base de la imagen cuando se carga en la memoria, y para los archivos de objetos, contiene la dirección del primer byte de la sección antes de que se aplique la reubicación.
- **`SizeOfRawData`:** Este campo contiene el tamaño de la sección en disco, debe ser múltiplo de `IMAGE_OPTIONAL_HEADER.FileAlignment`.  
- **`PointerToRawData`:** Un puntero a la primera página de la sección dentro del archivo, para imágenes ejecutables debe ser un múltiplo de `IMAGE_OPTIONAL_HEADER.FileAlignment`.
- **`PointerToRelocations`:** un puntero de archivo al comienzo de las entradas de reubicación para la sección. Está configurado en `0` para archivos ejecutables.
- **`PointerToLineNumbers`:** Un puntero de archivo al comienzo de las entradas de número de línea COFF para la sección. Se establece en `0` porque la información de depuración de COFF está en desuso.
- **`NumberOfRelocations`:** El número de entradas de reubicación para la sección, está configurado `0` para imágenes ejecutables.
- **`NumberOfLinenumbers`:** El número de entradas de número de línea de COFF para la sección, se establece en `0` porque la información de depuración de COFF está en desuso.
- **`Characteristics`:** Banderas que describen las características de la sección.  
    Estas características son cosas como si la sección contiene código ejecutable, contiene datos inicializados/no inicializados, puede compartirse en la memoria.  
    Puede encontrar una lista completa de las banderas de características de la sección en la [documentación oficial de Microsoft](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format) .

`SizeOfRawData` y `VirtualSize` puede ser diferente, y esto puede suceder por múltiples razones.

`SizeOfRawData` debe ser un múltiplo de `IMAGE_OPTIONAL_HEADER.FileAlignment`, por lo que si el tamaño de la sección es menor que ese valor, el resto se rellena y `SizeOfRawData` se redondea al múltiplo más cercano de `IMAGE_OPTIONAL_HEADER.FileAlignment`.  
Sin embargo, cuando la sección se carga en la memoria, no sigue esa alineación y solo se ocupa el tamaño real de la sección.  En este caso `SizeOfRawData`será mayor que`VirtualSize`

También puede ocurrir lo contrario.  Si la sección contiene datos no inicializados, estos datos no se contabilizarán en el disco, pero cuando la sección se asigne a la memoria, la sección se expandirá para reservar espacio en la memoria para cuando los datos no inicializados se inicialicen y utilicen posteriormente.  Esto quiere decir que la sección en disco ocupará menos que en memoria, en este caso `VirtualSize` será mayor que `SizeOfRawData`.

![foto](./img/Pasted%20image%2020221006164005.png)

`Raw Size` y `Virtual Size` corresponden a `IMAGE_SECTION_HEADER.SizeOfRawData` y `IMAGE_SECTION_HEADER.VirtualSize`.  
Podemos ver cómo estos dos campos se utilizan para calcular dónde termina la sección, tanto en el disco como en la memoria.  

Por ejemplo, si tomamos la sección`.text`, tiene una dirección sin procesar de `0x400` y un tamaño sin procesar de `0xE00`, si los sumamos, obtenemos `0x1200` cuál se muestra como el final de la sección en el disco.  
Del mismo modo, podemos hacer lo mismo con el tamaño y la dirección virtual, la dirección virtual es `0x1000` y el tamaño virtual es `0xD2C`, si los sumamos obtenemos `0x1D2C`.

#### SECTIONS

Las secciones son donde se almacenan los contenidos reales del archivo, estos incluyen cosas como datos y recursos que usa el programa, y también el código real del programa, hay varias secciones, cada una con su propio propósito

Algunas secciones tienen nombres especiales que indican su propósito, repasaremos algunos de ellos y se puede encontrar una lista completa de estos nombres en la [documentación oficial de Microsoft](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format)

-   **`.text`:** Contiene el código ejecutable del programa.
-   **`.data`:** contiene los datos inicializados.
-   **`.bss`:** contiene datos no inicializados.
-   **`.rdata`:** contiene datos inicializados de solo lectura.
-   **`.edata`:** contiene las tablas de exportación.
-   **`.idata`:** Contiene las tablas de importación.
-   **`.reloc`:** contiene información sobre la reubicación de la imagen.
-   **`.rsrc`:** Contiene recursos utilizados por el programa, estos incluyen imágenes, íconos o incluso archivos binarios incrustados.
-   **`.tls`:** ( **Almacenamiento** **local** de subprocesos **)** , proporciona almacenamiento para cada subproceso de ejecución del programa.

![foto](./img/Pasted%20image%2020221006163349.png)

**FUENTE:** [https://0xrick.github.io/win-internals/pe1/](https://0xrick.github.io/win-internals/pe1/)

## COFF - Common Object File Format

Es un formato para archivos ejecutables , de código de objeto y de biblioteca compartida que se utilizan en los sistemas Unix , antes de ser reemplazado en gran medida por ELF.

Extensiones: `.o` - `.obj` - `.lib`


## DLL (Dynamic Link Library)

Una DLL contiene una biblioteca de funciones y otra información a la que puede acceder un programa de Windows Cuando se inicia un programa, se crean enlaces a los archivos .dll necesarios. Si se crea un enlace dinámico, los archivos .dll solo se usarán cuando sea necesario. Los enlaces dinámicos ayudan a los programas a usar recursos, como la memoria y el espacio en el disco duro, de manera más eficiente. Algunas DLL vienen con el sistema operativo Windows, mientras que otras se agregan cuando se instalan nuevos programas. también puede terminar en .exe, .drv y .fon, solo para hacer las cosas más confusas.

Esto es importante para el analisis de malware y su creacion porque, como vimos en la respuesta a continuación, cada vez que un programa se descarga en una máquina (hasta un malware), se generará un archivo .dll.

#### DLL comunes y más importantes

- **Kernel32.dll** = Es un dll muy común que contiene funciones básicas como acceso y manipulación de memoria, archivos y hardware.
- **advapi32.dll** = Esta DLL proporciona acceso a los componentes principales de Windows avanzados, como el administrador de servicios y el registro.
- **user32.dll** = este dll contiene todos los componentes de la interfaz de usuario, como botones, desplazamiento, barras y componentes para controlar y responder a las acciones del usuario
- **gdi32.dll** = esta dll contiene funciones para mostrar y manipular gráficos
- **ws2_32.dll** = es un dll de red, un programa que accede a cualquiera de estos probablemente se conecta a una red o realiza tareas relacionadas con la red
- **Shell32.dll** = proporciona muchas funciones de Windows Shell, la interfaz gráfica de usuario (GUI) para Windows que incluye el escritorio, el menú de inicio, la reproducción automática y la barra de tareas, y en algunas versiones también Flip3D y los accesos. "Shell32.dll" es especialmente necesario para abrir páginas web y archivos.
- **ntdl.dll** = ntdll.dll es un módulo que contiene funciones del sistema NT. El archivo ntdll.dll es un archivo creado por Microsoft que tiene una descripción de "NT Layer DLL" y es el archivo que contiene las funciones del kernel de NT.

- [https://medium.com/mrx-007/basic-static-analysis-of-malware-and-common-dll-ef9455d49968](https://medium.com/mrx-007/basic-static-analysis-of-malware-and-common-dll-ef9455d49968)
